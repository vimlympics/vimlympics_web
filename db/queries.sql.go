// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (username, api_key) VALUES (?, ?)
`

type CreateUserParams struct {
	Username string
	ApiKey   string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser, arg.Username, arg.ApiKey)
}

const getCountryDetails = `-- name: GetCountryDetails :many
WITH "RankedScores" AS (
    SELECT 
        s.event_id,
        u.username,
        u.country,
        s.timems,
        s.date_entered,
        ROW_NUMBER() OVER (PARTITION BY s.event_id ORDER BY min(s.timems) ASC) AS "rank"
    FROM 
        scores s
LEFT    JOIN 
        users u ON s.user_id = u.user_id
    GROUP BY u.user_id, s.event_id
)
    SELECT username, country, timems, date_entered, rank,  e.event_type, event_level FROM RankedScores
LEFT JOIN events e on RankedScores.event_id = e.event_id
WHERE country = ?
ORDER BY rank asc
`

type GetCountryDetailsRow struct {
	Username    sql.NullString
	Country     sql.NullString
	Timems      int64
	DateEntered sql.NullTime
	Rank        interface{}
	EventType   sql.NullInt64
	EventLevel  sql.NullInt64
}

func (q *Queries) GetCountryDetails(ctx context.Context, country sql.NullString) ([]GetCountryDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCountryDetails, country)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountryDetailsRow
	for rows.Next() {
		var i GetCountryDetailsRow
		if err := rows.Scan(
			&i.Username,
			&i.Country,
			&i.Timems,
			&i.DateEntered,
			&i.Rank,
			&i.EventType,
			&i.EventLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountrySummary = `-- name: GetCountrySummary :many
WITH "RankedScores" AS (
    SELECT 
        s.event_id,
        u.country,
        s.timems,
        ROW_NUMBER() OVER (PARTITION BY s.event_id ORDER BY min(s.timems) ASC) AS "rank"
    FROM 
        scores s
    JOIN 
        users u ON s.user_id = u.user_id
    GROUP BY 
        s.user_id, s.event_id
)
SELECT 
    rs.country,
    SUM(CASE WHEN rs.rank = 1 THEN 1 ELSE 0 END) AS gold,
    SUM(CASE WHEN rs.rank = 2 THEN 1 ELSE 0 END) AS silver,
    SUM(CASE WHEN rs.rank = 3 THEN 1 ELSE 0 END) AS bronze,
    SUM(CASE WHEN rs.rank IN (1, 2, 3) THEN 1 ELSE 0 END) AS total_medals,
    SUM(CASE WHEN rs.rank = 1 THEN 3 WHEN rs.rank = 2 THEN 2 WHEN rs.rank = 3 THEN 1 ELSE 0 END) AS total_points
FROM 
    RankedScores rs
GROUP BY 
    rs.country
ORDER BY 
total_points DESC
LIMIT 10
`

type GetCountrySummaryRow struct {
	Country     sql.NullString
	Gold        sql.NullFloat64
	Silver      sql.NullFloat64
	Bronze      sql.NullFloat64
	TotalMedals sql.NullFloat64
	TotalPoints sql.NullFloat64
}

func (q *Queries) GetCountrySummary(ctx context.Context) ([]GetCountrySummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getCountrySummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountrySummaryRow
	for rows.Next() {
		var i GetCountrySummaryRow
		if err := rows.Scan(
			&i.Country,
			&i.Gold,
			&i.Silver,
			&i.Bronze,
			&i.TotalMedals,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventDetails = `-- name: GetEventDetails :many
    SELECT 
        s.event_id,
        u.username,
        u.country,
        s.timems,
        s.date_entered,
    e.event_type,
    e.event_level,
        ROW_NUMBER() OVER (PARTITION BY s.event_id ORDER BY min(s.timems) ASC) AS "rank"
    FROM 
        scores s
LEFT    JOIN 
        users u ON s.user_id = u.user_id
LEFT JOIN events e ON s.event_id = e.event_id
WHERE s.event_id = (SELECT event_id FROM events f WHERE f.event_type = ? and f.event_level = ?)
    GROUP BY u.user_id, s.event_id
`

type GetEventDetailsParams struct {
	EventType  int64
	EventLevel int64
}

type GetEventDetailsRow struct {
	EventID     int64
	Username    sql.NullString
	Country     sql.NullString
	Timems      int64
	DateEntered sql.NullTime
	EventType   sql.NullInt64
	EventLevel  sql.NullInt64
	Rank        interface{}
}

func (q *Queries) GetEventDetails(ctx context.Context, arg GetEventDetailsParams) ([]GetEventDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventDetails, arg.EventType, arg.EventLevel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventDetailsRow
	for rows.Next() {
		var i GetEventDetailsRow
		if err := rows.Scan(
			&i.EventID,
			&i.Username,
			&i.Country,
			&i.Timems,
			&i.DateEntered,
			&i.EventType,
			&i.EventLevel,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndivDetails = `-- name: GetIndivDetails :many
WITH "RankedScores" AS (
    SELECT 
        s.event_id,
        u.username,
        u.country,
        s.timems,
        s.date_entered,
        ROW_NUMBER() OVER (PARTITION BY s.event_id ORDER BY min(s.timems) ASC) AS "rank"
    FROM 
        scores s
LEFT    JOIN 
        users u ON s.user_id = u.user_id
    GROUP BY u.user_id, s.event_id
)
    SELECT country, timems, date_entered, rank, e.event_type, event_level FROM RankedScores
LEFT JOIN events e on RankedScores.event_id = e.event_id
WHERE username = ?
ORDER BY rank asc
`

type GetIndivDetailsRow struct {
	Country     sql.NullString
	Timems      int64
	DateEntered sql.NullTime
	Rank        interface{}
	EventType   sql.NullInt64
	EventLevel  sql.NullInt64
}

func (q *Queries) GetIndivDetails(ctx context.Context, username string) ([]GetIndivDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndivDetails, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndivDetailsRow
	for rows.Next() {
		var i GetIndivDetailsRow
		if err := rows.Scan(
			&i.Country,
			&i.Timems,
			&i.DateEntered,
			&i.Rank,
			&i.EventType,
			&i.EventLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndivSummary = `-- name: GetIndivSummary :many
WITH "RankedScores" AS (
    SELECT 
        s.event_id,
        u.username,
        u.country,
        s.timems,
        ROW_NUMBER() OVER (PARTITION BY s.event_id ORDER BY min(s.timems) ASC) AS "rank"
    FROM 
        scores s
LEFT    JOIN 
        users u ON s.user_id = u.user_id
    group by s.event_id, s.user_id
)
SELECT 
    rs.username,
    rs.country,
    SUM(CASE WHEN rs.rank = 1 THEN 1 ELSE 0 END) AS gold,
    SUM(CASE WHEN rs.rank = 2 THEN 1 ELSE 0 END) AS silver,
    SUM(CASE WHEN rs.rank = 3 THEN 1 ELSE 0 END) AS bronze,
    SUM(CASE WHEN rs.rank IN (1, 2, 3) THEN 1 ELSE 0 END) AS total_medals,
    SUM(CASE WHEN rs.rank = 1 THEN 3 WHEN rs.rank = 2 THEN 2 WHEN rs.rank = 3 THEN 1 ELSE 0 END) AS total_points
FROM 
    RankedScores rs
GROUP BY 
    rs.username
ORDER BY total_points DESC
LIMIT 10
`

type GetIndivSummaryRow struct {
	Username    sql.NullString
	Country     sql.NullString
	Gold        sql.NullFloat64
	Silver      sql.NullFloat64
	Bronze      sql.NullFloat64
	TotalMedals sql.NullFloat64
	TotalPoints sql.NullFloat64
}

func (q *Queries) GetIndivSummary(ctx context.Context) ([]GetIndivSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndivSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndivSummaryRow
	for rows.Next() {
		var i GetIndivSummaryRow
		if err := rows.Scan(
			&i.Username,
			&i.Country,
			&i.Gold,
			&i.Silver,
			&i.Bronze,
			&i.TotalMedals,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT user_id FROM users WHERE username = ?
`

func (q *Queries) GetUser(ctx context.Context, username string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUser, username)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserProfileData = `-- name: GetUserProfileData :one
SELECT country, api_key FROM users WHERE username = ?
`

type GetUserProfileDataRow struct {
	Country sql.NullString
	ApiKey  string
}

func (q *Queries) GetUserProfileData(ctx context.Context, username string) (GetUserProfileDataRow, error) {
	row := q.db.QueryRowContext(ctx, getUserProfileData, username)
	var i GetUserProfileDataRow
	err := row.Scan(&i.Country, &i.ApiKey)
	return i, err
}

const submitScore = `-- name: SubmitScore :execresult
INSERT INTO scores (user_id, event_id, timems)
SELECT 
    u.user_id, 
    e.event_id, 
    ?
FROM users u
LEFT JOIN events e ON e.event_level = ? AND e.event_type = ?
WHERE u.username = ? AND u.api_key = ?
  AND u.user_id IS NOT NULL
`

type SubmitScoreParams struct {
	Timems     int64
	EventLevel int64
	EventType  int64
	Username   string
	ApiKey     string
}

func (q *Queries) SubmitScore(ctx context.Context, arg SubmitScoreParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, submitScore,
		arg.Timems,
		arg.EventLevel,
		arg.EventType,
		arg.Username,
		arg.ApiKey,
	)
}

const updateUserCountry = `-- name: UpdateUserCountry :execresult
UPDATE users SET country = ? WHERE username = ?
`

type UpdateUserCountryParams struct {
	Country  sql.NullString
	Username string
}

func (q *Queries) UpdateUserCountry(ctx context.Context, arg UpdateUserCountryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUserCountry, arg.Country, arg.Username)
}
