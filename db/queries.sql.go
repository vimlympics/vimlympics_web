// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const getCountryDetails = `-- name: GetCountryDetails :many
WITH "RankedScores" AS (
    SELECT 
        s.event_id,
        u.username,
        u.country,
        s.timems,
        s.date_entered,
        ROW_NUMBER() OVER (PARTITION BY s.event_id ORDER BY min(s.timems) ASC) AS "rank"
    FROM 
        scores s
LEFT    JOIN 
        users u ON s.user_id = u.user_id
    GROUP BY u.user_id, s.event_id
)
    SELECT username, country, timems, date_entered, rank, event_type_name, event_level FROM RankedScores
LEFT JOIN events e on RankedScores.event_id = e.event_id
LEFT JOIN events_types et on e.event_type = et.event_type_id
WHERE country = ?
ORDER BY rank asc
`

type GetCountryDetailsRow struct {
	Username      sql.NullString
	Country       sql.NullString
	Timems        int64
	DateEntered   sql.NullTime
	Rank          interface{}
	EventTypeName sql.NullString
	EventLevel    sql.NullInt64
}

func (q *Queries) GetCountryDetails(ctx context.Context, country string) ([]GetCountryDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCountryDetails, country)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountryDetailsRow
	for rows.Next() {
		var i GetCountryDetailsRow
		if err := rows.Scan(
			&i.Username,
			&i.Country,
			&i.Timems,
			&i.DateEntered,
			&i.Rank,
			&i.EventTypeName,
			&i.EventLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountrySummary = `-- name: GetCountrySummary :many
WITH "RankedScores" AS (
    SELECT 
        s.event_id,
        u.country,
        s.timems,
        ROW_NUMBER() OVER (PARTITION BY s.event_id ORDER BY min(s.timems) ASC) AS "rank"
    FROM 
        scores s
    JOIN 
        users u ON s.user_id = u.user_id
    GROUP BY 
        s.user_id, s.event_id
)
SELECT 
    rs.country,
    SUM(CASE WHEN rs.rank = 1 THEN 1 ELSE 0 END) AS gold,
    SUM(CASE WHEN rs.rank = 2 THEN 1 ELSE 0 END) AS silver,
    SUM(CASE WHEN rs.rank = 3 THEN 1 ELSE 0 END) AS bronze,
    SUM(CASE WHEN rs.rank IN (1, 2, 3) THEN 1 ELSE 0 END) AS total_medals,
    SUM(CASE WHEN rs.rank = 1 THEN 3 WHEN rs.rank = 2 THEN 2 WHEN rs.rank = 3 THEN 1 ELSE 0 END) AS total_points
FROM 
    RankedScores rs
GROUP BY 
    rs.country
ORDER BY 
total_points DESC
LIMIT 10
`

type GetCountrySummaryRow struct {
	Country     string
	Gold        sql.NullFloat64
	Silver      sql.NullFloat64
	Bronze      sql.NullFloat64
	TotalMedals sql.NullFloat64
	TotalPoints sql.NullFloat64
}

func (q *Queries) GetCountrySummary(ctx context.Context) ([]GetCountrySummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getCountrySummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountrySummaryRow
	for rows.Next() {
		var i GetCountrySummaryRow
		if err := rows.Scan(
			&i.Country,
			&i.Gold,
			&i.Silver,
			&i.Bronze,
			&i.TotalMedals,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndivDetails = `-- name: GetIndivDetails :many
WITH "RankedScores" AS (
    SELECT 
        s.event_id,
        u.username,
        u.country,
        s.timems,
        s.date_entered,
        ROW_NUMBER() OVER (PARTITION BY s.event_id ORDER BY min(s.timems) ASC) AS "rank"
    FROM 
        scores s
LEFT    JOIN 
        users u ON s.user_id = u.user_id
    GROUP BY u.user_id, s.event_id
)
    SELECT country, timems, date_entered, rank, event_type_name, event_level FROM RankedScores
LEFT JOIN events e on RankedScores.event_id = e.event_id
LEFT JOIN events_types et on e.event_type = et.event_type_id
WHERE username = ?
ORDER BY rank asc
`

type GetIndivDetailsRow struct {
	Country       sql.NullString
	Timems        int64
	DateEntered   sql.NullTime
	Rank          interface{}
	EventTypeName sql.NullString
	EventLevel    sql.NullInt64
}

func (q *Queries) GetIndivDetails(ctx context.Context, username string) ([]GetIndivDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndivDetails, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndivDetailsRow
	for rows.Next() {
		var i GetIndivDetailsRow
		if err := rows.Scan(
			&i.Country,
			&i.Timems,
			&i.DateEntered,
			&i.Rank,
			&i.EventTypeName,
			&i.EventLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndivSummary = `-- name: GetIndivSummary :many
WITH "RankedScores" AS (
    SELECT 
        s.event_id,
        u.username,
        u.country,
        s.timems,
        ROW_NUMBER() OVER (PARTITION BY s.event_id ORDER BY min(s.timems) ASC) AS "rank"
    FROM 
        scores s
LEFT    JOIN 
        users u ON s.user_id = u.user_id
    group by s.event_id, s.user_id
)
SELECT 
    rs.username,
    rs.country,
    SUM(CASE WHEN rs.rank = 1 THEN 1 ELSE 0 END) AS gold,
    SUM(CASE WHEN rs.rank = 2 THEN 1 ELSE 0 END) AS silver,
    SUM(CASE WHEN rs.rank = 3 THEN 1 ELSE 0 END) AS bronze,
    SUM(CASE WHEN rs.rank IN (1, 2, 3) THEN 1 ELSE 0 END) AS total_medals,
    SUM(CASE WHEN rs.rank = 1 THEN 3 WHEN rs.rank = 2 THEN 2 WHEN rs.rank = 3 THEN 1 ELSE 0 END) AS total_points
FROM 
    RankedScores rs
GROUP BY 
    rs.username
ORDER BY total_points DESC
LIMIT 10
`

type GetIndivSummaryRow struct {
	Username    sql.NullString
	Country     sql.NullString
	Gold        sql.NullFloat64
	Silver      sql.NullFloat64
	Bronze      sql.NullFloat64
	TotalMedals sql.NullFloat64
	TotalPoints sql.NullFloat64
}

func (q *Queries) GetIndivSummary(ctx context.Context) ([]GetIndivSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndivSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndivSummaryRow
	for rows.Next() {
		var i GetIndivSummaryRow
		if err := rows.Scan(
			&i.Username,
			&i.Country,
			&i.Gold,
			&i.Silver,
			&i.Bronze,
			&i.TotalMedals,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const submitScore = `-- name: SubmitScore :execresult
INSERT INTO scores (user_id, event_id, timems)
SELECT u.user_id, e.event_id, ?
FROM users u
LEFT JOIN events e ON e.event_level = ? AND e.event_type = ?
WHERE u.username = ?
`

type SubmitScoreParams struct {
	Timems     int64
	EventLevel int64
	EventType  int64
	Username   string
}

func (q *Queries) SubmitScore(ctx context.Context, arg SubmitScoreParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, submitScore,
		arg.Timems,
		arg.EventLevel,
		arg.EventType,
		arg.Username,
	)
}
